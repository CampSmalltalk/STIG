<?xml version="1.0"?><st-source><!-- Name: STIG-JsonPackageName: STIG-JsonParcel: #('STIG-Json')ParcelDirectory: STIG-JsonSTIGRoot: STIGVersion: stic 4Date: 12:41:50 PM March 30, 2012 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.9 (mar12.4) of March 23, 2012 on March 30, 2012 at 12:41:50 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>JSON</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>stream char </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>STIG-Json</package></attributes></class><shared-variable><name>Whitespace</name><environment>JSON</environment><private>false</private><constant>true</constant><category>constants</category><initializer>String with: Character tab with: Character space with: Character cr</initializer><attributes><package>STIG-Json</package></attributes></shared-variable><methods><class-id>JSON</class-id> <category>private</category><body package="STIG-Json">get	^char ifNil: [ stream next ]		ifNotNil: [ :c | char = nil. c ]</body><body package="STIG-Json">peek	^char ifNil: [ char := stream next ]</body><body package="STIG-Json">read: count	^char		ifNil: [ stream next: count ]		ifNotNil: [ | out |			out := String new: count.			out at: 1 put: self get.			stream next: count - 1 into: out startingAt: 2.			out ]</body><body package="STIG-Json">skipWhitespace	[ Whitespace includes: (char := self get) ] whileTrue</body></methods><methods><class-id>JSON</class-id> <category>private-parsing</category><body package="STIG-Json">parse	self skipWhitespace.	char := self peek.	char = ${ ifTrue: [ ^self parseObject ].	char = $[ ifTrue: [ ^self parseArray ].	char = $" ifTrue: [ ^self parseString ].	char = $n ifTrue: [ ^self parseNull ].	char = $t ifTrue: [ ^self parseTrue ].	char = $f ifTrue: [ ^self parseFalse ].	char isDigit ifTrue: [ ^self parseNumber ].	self error: 'Invalid JSON'</body><body package="STIG-Json">parseArray	| array |	self get = $[ ifFalse: [ self error: 'Failed parsing array' ].	array := Array new writeStream.	self skipWhitespace.	[	self peek = $]	] whileFalse: [		array nextPut: self parse.		(self skipWhitespace; peek) = $, ifTrue: [			self get; skipWhitespace ] ].	self get.	^array contents</body><body package="STIG-Json">parseFalse	(self read: 5) = 'false' ifTrue: [^false].	self error: 'Failed parsing false'</body><body package="STIG-Json">parseNull	(self read: 4) = 'null' ifTrue: [^nil].	self error: 'Failed parsing null'</body><body package="STIG-Json">parseNumber		| number |	number := String new writeStream.	[ (char := self get) isDigit ] whileTrue: [ number nextPut: char ].	^Number readFrom: number contents readStream</body><body package="STIG-Json">parseObject	| object |	self get = ${ ifFalse: [ self error: 'Failed parsing object' ].	object := Dictionary new.	self skipWhitespace.	[	self peek = $}	] whileFalse: [ | key value |		key := self parseString.		(self skipWhitespace; get) = $: ifFalse: [ self error: 'Failed parsing object' ].		value := self skipWhitespace; parse.		object at: key put: value.		(self skipWhitespace; peek) = $, ifTrue: [			self get; skipWhitespace ] ].	self get.	^object</body><body package="STIG-Json">parseSpecialCharacter	| c |	c := self get.	c = $\  ifTrue: [ ^$\ ].	c = $" ifTrue: [ ^$" ].	c = $n ifTrue: [ ^Character cr ].	c = $t ifTrue: [ ^Character tab ].	c = $u ifTrue: [ ^self parseUnicodeCodePoint: (self read: 4) asLowercase ].	self error: 'Failed parsing special character'</body><body package="STIG-Json">parseString		| string c |	string := String new writeStream.	self get = $" ifFalse: [ self error: 'Failed parsing String' ].	[ (c := self get) = $" ] whileFalse: [		c = $\ ifTrue: [ c := self parseSpecialCharacter ].		string nextPut: c ].	^string contents</body><body package="STIG-Json">parseTrue	(self read: 4) = 'true' ifTrue: [^true].	self error: 'Failed parsing true'</body><body package="STIG-Json">parseUnicodeCodePoint: digits	| hex codePoint |	hex := '0123456789abcdef'.	codePoint := digits inject: 0 into: [ :nr :c | nr * 16 + (hex indexOf: c) - 1 ].	^codePoint asCharacter</body></methods><methods><class-id>JSON</class-id> <category>accessing</category><body package="STIG-Json">readFrom: source	stream := source.	self parse</body></methods><methods><class-id>JSON class</class-id> <category>instance creation</category><body package="STIG-Json">read: aStream	^self new readFrom: aStream</body></methods><methods><class-id>Core.Dictionary</class-id> <category>printing</category><body package="STIG-Json">jsonWriteOn: stream tabs: tabs	stream nextPut: ${; tab.  	self isEmpty ifTrue: [ stream nextPut: $}. ^self ].	self keys sorted		do: [ :key | stream nextPut: $"; nextPutAll: key; nextPutAll: '" : '.			(self at: key) jsonWriteOn: stream tabs: tabs + 1 ]		separatedBy: [ stream nextPut: $,; cr.			tabs + 1 timesRepeat: [ stream tab ] ].	stream nextPutAll: ' }'</body></methods><methods><class-id>Core.Number</class-id> <category>printing</category><body package="STIG-Json">jsonWriteOn: stream tabs: tabs	stream print: self</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>printing</category><body package="STIG-Json">jsonWriteOn: stream tabs: tabs	stream nextPutAll: 'null'</body></methods><methods><class-id>Core.ArrayedCollection</class-id> <category>printing</category><body package="STIG-Json">jsonWriteOn: stream tabs: tabs	stream nextPut: $[; tab.  	self isEmpty ifTrue: [ stream nextPut: $]. ^self ].	(1 to: self size)		do: [ :i | (self at: i) jsonWriteOn: stream tabs: tabs + 1 ]		separatedBy: [ stream nextPut: $,; cr.			tabs + 1 timesRepeat: [ stream tab ] ].	stream nextPutAll: ' ]'</body></methods><methods><class-id>Core.False</class-id> <category>printing</category><body package="STIG-Json">jsonWriteOn: stream tabs: tabs	stream nextPutAll: 'false'</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="STIG-Json">jsonWriteOn: stream	self jsonWriteOn: stream tabs: 0</body><body package="STIG-Json">jsonWriteOn: stream tabs: tabs	| keys |	stream nextPut: ${.	keys := self class instVarNames.	keys isEmpty ifTrue: [ stream nextPut: $}. ^self ].	keys do: [ :var | stream nextPut: $"; nextPutAll: var; nextPutAll: '" : '.			(self instVarAt: var) jsonWriteOn: stream tabs: tabs + 1 ]		separatedBy: [ stream nextPut: $,; cr.			tabs + 1 timesRepeat: [ stream tab ] ].	stream nextPutAll: ' }'</body></methods><methods><class-id>Core.KeyedCollection</class-id> <category>printing</category><body package="STIG-Json">jsonWriteOn: stream tabs: tabs	stream nextPut: ${; tab.  	self isEmpty ifTrue: [ stream nextPut: $}. ^self ].	self keys sorted		do: [ :key | stream nextPut: $"; nextPutAll: key; nextPutAll: '" : '.			(self at: key) jsonWriteOn: stream tabs: tabs + 1 ]		separatedBy: [ stream nextPut: $,; cr.			tabs + 1 timesRepeat: [ stream tab ] ].	stream nextPutAll: ' }'</body></methods><methods><class-id>Core.True</class-id> <category>printing</category><body package="STIG-Json">jsonWriteOn: stream tabs: tabs	stream nextPutAll: 'true'</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>printing</category><body package="STIG-Json">jsonWriteOn: stream tabs: tabs	stream nextPut: $".	self do: [ :c |		c codePoint &lt; 128			ifTrue: [ ('"\' includes: c) ifTrue: [ stream nextPut: $\ ].					stream nextPut: c ]			ifFalse: [ stream nextPutAll: '\u'.				c codePoint printOn: stream base: 16 digitsToPad: 4 highDigit: 4 ] ].	stream nextPut: $"</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>KeyedCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>ArrayedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>False</name><environment>Core</environment><super>Core.Boolean</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Number</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>True</name><environment>Core</environment><super>Core.Boolean</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class></st-source>